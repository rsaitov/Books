# Глава 11 - Что дальше?

## Деревья

В основу **бинарного дерева поиска** заложена идея моментальной сортировки по мере добавления новых элементов. Все узлы левого поддерева содержат меньшие значения, а все узлы правого поддерева - большие значения.

Деревья могут быть не очень эффективны, если дерево не сбалансировано (перекошено влево или вправо). Существуют специальные бинарные деревья поиска, способные к самобалансировке (как, например __красно-черные деревья__).

Более сложные структуры данных:
- в-деревья;
- красно-черные деревья;
- кучи;
- скошенные (splay) деревья.

## Инвертированные индексы
Хэш-таблица, связывающая слова с местами, в которых эти слова встречаются, называется **инвертированным индексом**.

## Преобразование Фурье
Алгоритм, позволяющий разделить объект на составные части. Примеры: музыкальный формат MP3, графический формат JPG. Работа приложения Shazam - нахождение песни по отрывкам - строится на основе этого алгоритма.

## Параллельные алгоритмы
Позволяют использовать многоядерность или многопроцессорность современных компьютеров. Но прирост времени выполнения не линеен. Это объясняется несколькими причинами:
- затраты ресурсов на управление параллелизмом;
- распределение нагрузки.

## MapReduce
Алгоритм MapReduce - известный представитель семейства распределённых алгоритмов - возможность выполнения на множестве машин. Для работы с ним можно воспользоваться популярной системой с открытым кодом Apache Hadoop.

Распределенные алгоритмы хорошо работают в тех ситуациях, когда вам нужно выполнить большой объем работы и вы хотите сократить время ее выполнения. В основе технологии MapReduce лежат две простые идеи: функция отображения __map__ и функция свертки __reduce__.

## Фильтры Блума и HyperLogLog
Сталкиваясь с огромными объемами данных, приходится действовать более изобретательно, например, можно воспользоваться __вероятностными структурами данных__, которые называют **фильтрами Блума**. Они дают ответ, который может оказаться ложным, но с большой вероятностью является правильным.

**HyperLogLog** аппроксимирует количество уникальных элементов в множестве. Как и фильтры Блума, он не дает точного ответа, но выдает достаточно близкий результат с использованием малой части памяти, которую обычно занимает такая задача.

Если вы используете большие объемы данных и вас устраивают приближенные ответы - воспользуйтесь вероятностными алгоритмами.

## Алгоритмы SHA
Secure Hash Algorithm (SHA) получает строку и возвращает хеш-код этой строки. Является односторонным - вы можете получить хеш-код строки, но не можете восстановить исходную строку по хеш-коду. 
Может использоваться для:
- сравнения двух файлов;
- проверки паролей.

## Локально-чувствительное хеширование
Если в исходной строке изменить один символ, хеш-код полностью изменится. Это особенность хеширования SHA - __локально-нечувствительность__. 

Если нужно обратное - на помощь приходит алгоритм **Simhash**. Это позволяет сравнивать хеш-коды и определять, насколько походи две строки. Используется для выявления сходства между фрагментами текста.

## Обмен ключами Диффи-Хеллмана
Решает проблемы:
- знание шифра обеими сторонами не обязательно;
- расшифровать зашифрованные сообщения __чрезвычайно__ сложно.
Ипользует 2 ключа: открытый и закрытый. Открытый известен обеим сторонам. Его не нужно скрывать. Когда другая сторона захочет отправить вам сообщение, она зашифрует его с применением открытого ключа. Зашифрованное сообщение можно расшифровать только с закрытым ключом.

Алгоритм Диффи-Хеллмана применяется на практике вместе с его наследним RSA.

## Линейное программирование
Используется для максимизации некоторой характеристики при заданных ограничениях. Линейное программирование - более общая тема, а задачи с графами составляют ее подмножество. Используется __симплекс-метод__.