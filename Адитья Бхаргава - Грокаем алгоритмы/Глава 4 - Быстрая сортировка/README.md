# Глава 4 - Быстрая сортировка

## Стратегия "разделяй и властвуй"

1. Определите простейший случай как базовый.
2. Придумайте, как свести задачу к базовому случаю.

Когда вы пишете рекурсивную функцию, в которой задействован массив, базовым случаем часто оказывается пустой массив или массив из одного элемента. Если вы не знаете, с чего начать, - начните с этого.

## Упражнение 4.1
**Задача**: Просуммировать все числа в массиве

```C#
using System;
					
public class Program
{
	public static void Main()
	{
		int[] arrayOfIntegers = {3, 4, 6, 7};
		var sumOfArray = GetSum(arrayOfIntegers);
		Console.WriteLine(sumOfArray);
	}
	
	private static int GetSum(int[] arr)
	{
		if (arr.Length == 1)
			return arr[0];
		
        var newArr = new int[arr.Length-1];
        Array.Copy(arr, 1, newArr, 0, arr.Length-1);
        return arr[0] + GetSum(newArr);
	}
}
```

## Упражнение 4.2
**Задача**: Напишите рекурсивную функцию для подсчета элементов в списке

```Python
def count(list):
    if (count) == []
        return 0    
    return 1 + count(list[1:])
```

## Упражнение 4.3
**Задача**: Найдите наибольшее число в списке

```Python
def max(list):
    if (len(list) == 2)
        return list[0] if list[0]>list[1] else list[1]  

    sub_max = max(list[0], list[1:])

    return list[0] if list[0] > sub_max else sub_max
```

Базовым случаем для бинарного поиска является массив, содержащий всего один элемент. В рекурсивном случае для бинарного поиска массив делится пополам, одна половина отбрасывается, а для другой половины проводится бинарный поиск.

## Алгоритм быстрой сортировки

Базовым случаем является отсутствие элементов в массиве или массив из одного элемента.

Затем в массиве выбирается элемент, который называется __опорным__. Теперь мы находим элементы, меньшие опорного, и элементы, большие опорного. Этот процесс называется __разделением__. Теперь у нас имеются:
- подмассив всех элементов, меньших опорного;
- опорный элемент;
- подмассив всех элементов, больших опорного.

Два подмассива не отсортированы - они просто выделены из исходного массива. Но если бы они __были__ отсортированы, то провести сортировку всего массивы было бы несложно.

Программный код быстрой сортировки:

```Python
def quicksort(array):
    if len(array) < 2:  #базовый случай
        return array    
    else:
        pivot = array[0]
        less = [i for i in array[1:] if i <= pivot] #подмассив всех элементов, меньших опорного
        greater = [i for i in array[1:] if i > pivot] #подмассив всех элементов, больших опорного
        return quicksort(less) + [pivot] + quicksort(greater)

print quicksort([10, 5, 2, 3])
```

На сложность алгоритма не влияют константы, если два алгоритма имеют разное время "О-большое". Однако в некоторых случаях константа __может__ иметь значение. Один из таких примеров - быстрая сортировка и сортировка слиянием (O(n log n)). На практике быстрая сортировка работает быстрее, потому что средний случай встречается намного чаще худшего.