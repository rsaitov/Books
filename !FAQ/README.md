# Ответы на часто задаваемые вопросы

## Многопоточность
### Какие есть инструменты для работы с потоками в .NET?
В .NET есть прямой доступ к работе с потоками через класс **Thread** из пространства имен **System.Threading**. Он даёт доступ не к потокам самой ОС, а к обертке над ними, так называемым Managed Threads. В пространстве System.Threading есть много полезного, например, класс **Monitor**, который чаще используется через встроенный в язык оператор **lock**. Еще там есть обертки над мьютексами и семафорами ОС и несколько классов для реализации многопоточных событий - Manual, Auto, Reset-event'ы.

Кроме того, есть Slim-версии для большого количества примитивов. Чаще всего лучше использовать именно их. 

В .NET реализован очень крутой **пул потоков**. Идея в том, что поток - это ресурс тяжелый и каждый раз его выкидывать за ненадобностью, если мы потратили так много ресурсов на его создание, не стоит. Поэтому вернём его в пул и переиспользуем обратно.

На практике мы чаще пользуемся более высокоуровневой абстракцией - классом **Task** из пространства System.Threading.Task и операторами **async/await**, работающими с ними. Они отлично подходят для IO-операций, которые в основном обычно и тупят. Они отлично справляются с задачей увода таких операций из основного контекста. Ещё они были чудовищно полезны в UI-приложениях, ведь взаимодействовать с контролами можно только из главного потока. А оператор await возвращал нас в него после асинхронной операции довольно прозрачным образом. За счет такого синтаксического сахара и кодогенерации во время компиляции получалось, что асинхронный код начал выглядеть почти так же просто, как и синхронный.

Среди высокоуровневых инструментов, кроме task'ов, в .NET'e есть еще **PLINQ**. У нас было много разных LINQ - Link-to-collections (удобное оперирование с последовательностями), Link-to-sql (трансляция C# в SQL-запросы). В какой-то момент появился PLINQ, распараллеливающий цепочки команд на нужное количество потоков. PLINQ сам разберётся сколько в вашей коллекции элементов и как оптимальным образом распараллелить на представленные в системе ресурсы. В принципе, если он не будет достаточно хорошо угадывать, у вас есть особые механизмы которые позволят подсказать рантайму как именно вести себя именно с вашей коллекцией именно в контексте вашей программы. Впрочем это нужно достаточно редко, ведь в сам фреймворк встроено большое количество разных эвристик.

Еще немного сбоку от основного .нета (в основноую поставку не включено, но является частью .NEt Foundation, типа набор одобренных Microsoft набор библиотек). Есть несколько библиотек для реализации такой высокоуровневой концепции для многопоточной и даже распределенных вычислений, как акторы. Там есть Microsoft Orleans от самих майкрософт и Akka.NET.

### Чем опасны потоки? Что такое Dead Lock и Race Condition?
Состояние гонки (Race Condition) - это проблема, когда результат выполнения программы может меняться в зависимости от прихоти планировщика потоков, рантайма и т.п.

### Slim версии примитивов синхронизации. В чем их опасность? Когда использовать?
По умолчанию **сихронизация проходит через ядро ОС**. Для этого поток переводится в особое состояние. Если ресурс очень быстро освободится, то для того, чтобы вернуть поток в свободное состояние и пройти его через все недра бюрократии ОС, уйдет довольно много времени. Еси все блокировки крайне кратковременные, то это время может занимать больше, чем полезная работа. 

В противовес есть синхронизация через **SpinWait**. По сути это цикл на сколько-то итераций, который закончит свое выполнение сразу как ресурс освободится. Крайне эффективен для коротких блокировок, вы получите ресурс сразу как он освободится. Работает с данными внутри одного процесса.

**Slim-версии** - гибридный подход, когда сначала вы ждете в режиме SpinWait'a и если не получили блокировку очень быстро, то переходите в режим ядра. Но есть и минус - если из разных потов придет очень большое количество запросов на блокировку, программа начнёт тормозить не из-за того, что она делает, а изза обслуживания блокировок.

**ReaderWriterLockSlim** - блокировка с управлением доступом, позволяющая иметь много операций на чтение, а на запись - только одна.

### Что такое Interlocked
### CPU Bound vs IO Bound
### Как понять на сколько потоков распараллеливать ваш код?
Закон Амдала.
### Как отменять Task'и?
CancellationTokenSource и CancellationToken.
Если есть более 1 причины отменить такс - LinkedCancellationTokenSource.
### Как отслеживать прогресс выполнения асинхронной таски?
### Почему плохо использовать Task без await и async void? Когда можно?
Fire and forget - кидаете работу на выполнение и результат не нужен.
### Как связаны Threads и Task?
Таски выполняются на пуле потоков. Некоторые таски могут побывать на десятке потоков. А могут быть другие, которые закомплитятся вообще не побывав ни на одном потоке.

## Authentication
### Fundamentals
Process of verifying someone's identity.

Factors:
- [Knowledge] Username / Password
- [Knowledge] Security Codes
- [Posession] Hard Tokens / Soft Tokens
- [Qualities] Biometric

Miltifactor Authentication (MFA) - type of auth where we rely on more than one factor. Much more secure than Single Factor Authentication.

Two Factor Authentication (2FA) - MFA with 2 factors.

### Authentication vs Authorization
Authentication - process of verifying identity.
Authorization - process of checking the permission of the authenticated user.

### Auth Strategies
- Basic Authentication
- Session based Authentication
- Token based Authentication
- JWT Authentication
- OAuth - open Authorization
- Single Sign On (SSO)

### Basic Authentication
Basic Authentication != Username / Password
Basic Authentication is a part of Http Specification.

Server doesn't find **Authorization header** and response with header:

```
WWW-Authenticate: Basic realm="some_realm".
```

Client browser shows auth screen for user. After submitting the browser automatically encode the credentials using base64 encoding and set the Authorization header of the request:

```
Authorization: Basic base64("username:password")
```

Server decode the header and verify credentials. If both are valid the server respond with successfull response.

**Warning**: Anyone between you and browser can intercept auth header and get your credentials. Always use **https** instead of http to avoid this.