## Глава 22 - Тестирование, выполняемое разработчиками
Тестирование - самая популярная методика повышения качества, подкрепленная многими исследованиями и богатым опытом разработки коммерческих приложений.
Виды тестирования:
- **Блочное тестирование** - тестирование полного класса, метода или небольшого приложение, написанного одним программистом или группой, выполняемое отдельно от прочих частей системы.
- **Тестирование компонента** - тестирование класса, пакета, разработанного несколькими программистами или группами, выполняемое в изоляции от остальных частей системы.
- **Интеграционное тестирование** - совместное выполнение двух или более классов, пакетов, компонентов или подсистем, созданных несколькими программистами или группами.
- **Регрессивное тестирование** - повторное выполнение тестов, направленное на обнаружение дефектов в программе, уже прошедшей этот набор тестов.
- **Тестирование системы** - выполнение ПО в его окончательной конфигурации, интегрированного с другими программными и аппаратными системами.

Тестирование обычно разделяют на 2 обширные категории: "тестирование методом черного ящика" и "тестирование методом белого ящика". В первом случае тестировщик не владеет сведениями о внутренеей работе тестируемого элемента.

Ограничения тестирования, выполняемого разработчиками:
- разработчики обычно выполняют "чистые тесты". Разработчики склонны тестировать код на предмет того, работает ли он (чистые тесты), а не пытаться нарушить его работу всевозможными способами (грязные тесты);
- разработчики часто имеют слишком оптимистичное представление о покрытии кода тестами;
- разработчики часто упускают из виду более сложные аспекты покрытия кода тестами.
### Приёмы тестирования
Нужно выбирать несколько тестов, позволяющих найти разные ошибки, а не использовать множество тестов, раз за разом приводящих к одному результату.

**Структурированное базисное тестирование** - вы должны протестировать каждый оператор программы хотя бы раз.

**Тестирование, основанное на потоках данных** - поток управления и оток данных одинаково важны. Главная идея тестирования, основанного на потоках данных, в том, что использование данных не менее подвержено ошибкам, чем поток управления.

Данные могут находиться в 3х состояниях: определение, использование и уничтожение. Вход - поток управления входит в метод, выход - поток управления покидает метод. Внимание заслуживают следующие жизненные циклы переменных:
- определение - определение;
- определение - выход;
- определение - уничтожение;
- вход - уничтожение;
- вход - использование;
- уничтожение - уничтожение;
- уничтожение - использование;
- использование - определение.

**Разделение на классы эквивалентности** - если 2 теста приводят к обнаружению одних и тех же ошибок, вам нужен лишь один из них. Понятие "разделение на классы эквивалентности" формализует эту идею и помогает уменьшить число нужных тестов. Разделение не скажет вам много нового о программе, если вы уже покрыли её базисным тестированием и тестированием, основанным на потоках данных. Однако оно поезно, если вы смотрите на программу извне (с точки зрения спецификации, а не исходного кода) или если данные сложны, а эта сложность плохо отражена в логике программы.

**Угадывание ошибок** - формальные методики тестирования хорошие программисты дополняют менее формальными эвристическими методиками. Одна из них - угадывание ошибок (error guessing). В основе вполне разумная идея - создание тестов на основе обдуманных предположений о вероятных источниках ошибок.

**Аналих граничных условий** - одна из самых плодотворных областей тестирования - ошибки занижения или завышения на 1. Сложные граничные условия: максимальные и минимальные значения переменных, перемножение двух больших положительных чисел, двух больших отрицательных чисел, одни из переменных = 0, все переданные в метод строки имеют необычно большую длину?

**Классы плохих данных**:
- недостаток данных или их отсутствие;
- избыток данных;
- неверный вид данных (некорректные данные);
- неверный размер данных;
- неинициализированные данные.

**Классы хороших данных**:
- номинальные случаи: средние, ожидаемые значения;
- минимальная нормальная конфигурация;
- максимальная нормальная конфигурация;
- совместимость со старыми данными.

Используйте тесты, позволяющие легко проверить результаты вручную. При использовании любого числа из одного и того же класса эквивалентности вероятность нахождения ошибки одинакова. Поэтому используйте 20 000 вместо 90 783,82.

### Типичные ошибки
Для достижение максимальной эффективности тестирования мы должны как можно больше знать о нашем враге - ошибках. Большинство ошибок обычно концентрируются в нескольких особенно дефектных методах. 

Главный закон контроля качества ПО - **повышение качества сокращает сроки и снижает общую стоимость разработки системы**.

- большинство ошибок имеет довольно ограниченную область видимости;
- многие ошибки не связаны с конструированием;
- как правило, ошибки конструирования лежат на совести программистов;
- распространённой причиной проблем являются опечатки;
- часто причиной ошибок является неправильное понимание проекта;
- большинство ошибок легко исправить;
- оценивайте опыт борьбы с ошибками в своей организации.

Не забывайте про ошибки самого тестирования. Тесты обычно пишутся на ходу, не уделяя должного внимания проектированию и конструированию.
Советы по снижению ошибок в тестах:
- проверяйте свою работу. Анализируйте код каждого теста строка за строкой при помощи отладчика, как вы проверяли бы код готового приложения;
- планируйте тестирования программы так же, как и её разработку;
- храните тесты;
- встраивайте блочные тесты в среду тестирования.

### Инструменты тестирования
**Создание лесов для тестирования отдельных классов** - по сути искуственно созданная среда с mock и stub-объектами, позволяющая протестировать логику отдельного компонента, имитируя нужное поведение зависимых объектов.

**Инструменты сравнения файлов**. Можно записать результат в файл и сравнить его с эталонным.

**Генераторы тестовых данных**. Правильно спроектированные генераторы случайных данных способны генерировать комбинации тестовых данных, о которых вы могли бы не подумать.

**Мониторы покрытия кода тестами** - инструмент, который следит за тем какой код тестировался, а какой - нет. Тестирование, выполняемое без измерения покрытия кода тестами, обычно охватывает только 50-60% кода.

**Регистраторы данных** - подобно "черному ящику" может следить за программой и собирать информацию о ее состоянии в случае краха.

**Символические отладчики**

**Инструменты возмущения состояния системы**:
- заполнение памяти;
- "встряхивание памяти";
- селективный сбой памяти;
- проверка доступа к памяти (проверка границ).

**Базы данных для хранения информации об ошибках** - мощный инструмент тестирования.

### Оптимизация процесса тестирования
- планирование тестирования;
- повторное (регрессивное) тестирование;
- автоматизированное тестирование.

### Протоколы тестирования
Вы должны оценивать проект, чтобы можно было сказать, улучшается ли он в результате изменений или ухудшается. Вот некоторые категории данных, которые можно собирать с целью оценки проекта:
- административное описание дефекта (дата обнаружение, сотрудник, номер сборки, дата исправления);
- полное описание проблемы;
- действия, предпринятые для воспроизведения проблемы;
- предложенные способы решения;
- родственные дефекты;
- тяжесть проблемы (критическая, "неприятная" или косметическая);
- источник дефекта: выработка требований, проектирование, кодирование или тестирование;
- вид дефекта кодирования: ошибка завышения/занижения на 1, ошибка присваивания, недопустимый индекс итп;
- классы и методы, изменённые при исправлении дефекта;
- число строк, затронутых дефектом;
- время, ушедшее на нахождение дефекта;
- время, ушедшее на исправление дефекта.
Собирая эти данные, можно будет подсчитывать некоторые показатели, позволяющие сделать вывод об изменении качества проекта:
- число дефектов в каждом классе;
- число дефектов в каждом методе;
- среднее время тестирования в расчете на один обнаруженный дефект;
- среднее число обнаруженных дефектов в расчете на один тест;
- среднее время программирования в расчете на один исправленный дефект;
- процент кода, покрытого тестами;
- число дефектов, относящихся к каждой категории тяжести.

**Личные протоколы тестирования**. Кроме протоколов тестирования уровня проекта, можно хранить личные протоколы тестирования. Можете включать в них контрольные списки ошибок, которые вы допускаете чаще всего, и указывать время, затрачиваемое вами на написание кода, его тестирование и исправление ошибок.