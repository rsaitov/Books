## Глава 24 - Рефакторинг
Осознав, что эволюция ПО во время разработки - неизбежный и важный процесс и спланировав его, вы сможете извлечь из него выгоду. Главное правило эволюции ПО - эволюция должна повышать внутреннее качество программы.

**Рефакторинг** - изменение внутренней структуры ПО без изменения его наблюдаемого поведения, призванное облегчить его понимание и удешевить модификацию. Разумные причины выполнения рефактиринга ("запахи" кода):
- код повторяется. Копирование и вставка кода - следствие ошибки проектирования.
- метод слишком велик. Если вам кажется, что после разделения одного метода на несколько код станет яснее, создайте дополнительные методы.
- цикл слишком велик или слишком глубоко вложен в другие циклы;
- класс имеет плохую связность;
- интерфейс класса не формирует согласованную абстракцию;
- метод принимает слишком много параметров;
- отдельные части класса изменяются независимо от других частей;
- при изменении программы требуется параллельно изменять несколько классов;
- вам приходится параллельно изменять несколько иерархий наследования;
- вам приходится параллельно изменять несколько блоков case;
- родственные элементы данных, используемые вместе, не организованы в классы;
- метод использует больше элементов другого класса, чем своего собственного;
- элементарный тип данных перегружен;
- класс имеет слишком ограниченную функциональность. Может удалить класс, распределив его обязанности между другими классами?
- по цепи методов передаются бродячие данные;
- объект-посредник ничего не делает;
- один класс слишком много знает о другом классе;
- метод имеет неудачное имя;
- данные-члены сделаны открытыми;
- подкласс использует только малую долю методов свои предков;
- сложный код объясняется при помощи комментариев;
- код содержит глобальные переменные;
- перед вызовом методы выполняется подготовительный код (после вызова методы выполняется код "уборки");
- программа содержит код, который может когда-нибудь понадобиться.

### Отдельные виды рефакторинга
**Рефакторинг на уровне данных**
- замена магического числа на именованную константу;
- присвоение переменной более сного или информативного имени;
- встраивание выражения в код. Замените промежуточную переменную, которой присваивается результат вычисления выражения, на само выражение;
- замена выражения на вызов метода. Устранение из кода повторяющихся выражений.
- введение промежуточной переменной;
- преобразование многоцелевой переменной в несколько одноцелевых переменных;
- использование локальной переменной вместо параметра;
- преобразование элементарного типа данных в класс;
- преобразование набора кодов в класс или перечисление;
- преобразование набора кодов в класс, имеющий производные классы;
- преобразование массива в класс;
- инкапсуляция набора;
- замена традиционной записи на класс данных.

**Рефакторинг на уровне отдельных операторов**
- декомпозиция логического выражения;
- вынесение сложного логическоо выражения в грамотно названную булеву функцию;
- консолидация фрагментов, повторяющихся в разных частях условного оператора;
- использование оператора break или return вместо управляющей переменной цикла;
- возврат из метода сразу после получения ответа вместо установки возвращаемого значения внутри вложенных операторов if-then-else;
- замена условных операторов (особенно многочисленных блоков case) на вызов полиморфного метода;
- создание и использование "пустых" объектов вместо того, чтобы проверять, равно ли значение null.

**Рефакторинг на уровне отдельных методов**
- извлечение метода из другого метода;
- встраивание кода метода;
- преобразование объемного метода в класс;
- замена сложного алгоритма на простой;
- добавление параметра;
- удаление параметра;
- отделение операций запроса данных от операций изменения данных;
- объединение похожих методов путем их параметризации;
- разделение метода, поведение которого зависит от полученных параметров;
- передача в метод целого объекта вместо отдельных полей;
- передача в метод отдельных полей вместо целого объекта;
- инкапсуляция нисходящего приведения типов.